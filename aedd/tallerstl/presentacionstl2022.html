<!DOCTYPE html>
<html>
  <head>
    <title>AEDD - STL</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }
      
      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }
      .center {
        float: center;
      }
      
    </style>
  </head>
  <body>
    <textarea id="source">


layout: true
class: inverse, center, middle
---

# Taller de Estructuras Dinámicas - C++
## Algoritmos y Estructuras de Datos
### Tomás Assenza

???
---

layout: false
class: center, middle


## "There are only two hard things in Computer Science: cache invalidation and naming things."

Phil Karlton

## "The best way to prepare (to be a programmer) is to write programs, and to study great programs that other people have written."

Bill Gates 

---

# Contenidos
1. ¿Por qué estudiar estructuras dinámicas?
2. Vector
3. Map
4. Set (Ordered-Unordered Set)

???

---

class: inverse, center, middle


# ¿Por qué estudiar estructuras dinámicas?


---

layout: false

# ¿Por qué estudiar estructuras dinámicas?

--

* Competencias de programación.

.center[
![ACM ICPC](https://user-images.githubusercontent.com/42981462/192936888-847a786c-ccf0-451f-b7b2-27c0e19df5e3.png)
]
---

# ¿Por qué estudiar estructuras dinámicas?

* Competencias de programación.
* Entrevistas laborales (y trabajo en general).

.center[
![5847f9cbcef1014c0b5e48c8](https://user-images.githubusercontent.com/42981462/192937657-708e5cda-c0c4-4590-bcf8-a65b4d1d764f.png) ![meta-logo-meta-by-facebook-icon-editorial-logo-for-social-media-free-vector](https://user-images.githubusercontent.com/42981462/192937796-81965297-cf58-4fca-b74c-1ac6271bcb78.jpg)
]

---

# ¿Por qué estudiar estructuras dinámicas?

* Competencias de programación.
* Entrevistas laborales (y trabajo en general).
* Útiles en I+D.

.center[
![utn-formal-logo](https://user-images.githubusercontent.com/42981462/192938091-42b2cdec-1798-4ef2-81bf-37ed5448e951.png)
]

---

# ¿Por qué estudiar estructuras dinámicas?

* Competencias de programación.
* Entrevistas laborales (y trabajo en general).
* Útiles en I+D.
* Mayor facilidad de uso por funciones pre-armadas.

--

(Y por todo lo que deberíamos estudiar Algoritmos y Estructuras de Datos)

---

class: inverse, center, middle

# Vector

---

.left-column[
  ### Array
  ### Vector
]
.right-column[
Conceptos generales:
- Lista, o arreglo dinámico.
]

???
Referencias:
https://en.cppreference.com/w/cpp/container/vector

---

.left-column[
  ### Array
  ### Vector
]
.right-column[
Conceptos generales:
- Lista, o arreglo dinámico.
- El tamaño físico es igual al tamaño lógico y puede variar.
]

???
Referencias:
https://en.cppreference.com/w/cpp/container/vector

---

.left-column[
  ### Array
  ### Vector
]
.right-column[
Conceptos generales:
- Lista, o arreglo dinámico.
- El tamaño físico es igual al tamaño lógico y puede variar.
- Existe una estructura para los arreglos estáticos llamada Array. Vector cuenta con más funciones por ser dinámico.
]

???
Referencias:
https://en.cppreference.com/w/cpp/container/vector

---

# .center[Vector]
```c++
#include <vector>
```

### Declaración

```c++
vector<tipoDeDato> nombreDelVector; //vector de tamaño 0
vector<tipoDeDato> nombreDelVector2(tamaño, valor); //vector de tamaño <tamaño>, con cada uno de sus elementos igualados a <valor>.
```

--

### Inicialización

```c++
vector<tipoDeDato> nombreDelVector {dato1, dato2, dato3}; //vector {dato1, dato2, dato3} de tamaño 3
```

--

### Acceso y modificación de elementos

```c++
nombreDelVector[indice] = nuevoValor;
```

???
También cuenta, al igual que array, con la función .at como alternativa a al operador [].

---

### .center[Vector - Funciones integradas]

Imaginemos los vectores definidos como

```c++
vector<int> vector1 {1, 2, 3}; //Vector de tamaño 3
vector<int> vector2 {4, 5, 6}; //Vector de tamaño 3
```

--

#### Función front y back (acceso al primer o último elemento).

```c++
cout << vector1.front(); // Imprime 1
cout << vector1.back(); // Imprime 3
```

--

#### Funciones empty y size

```c++
cout << vector1.empty() //Imprime 0 (devuelve false) ya que contiene elementos.
cout << vector1.size() //Imprime 3 ya que el tamaño es 3.
```
--

#### Función swap

```c++
vector1.swap(vector2); //Intercambia el contenido de los vectores vector1 = {1,2,3}, vector2 = {4,5,6} quedando vector1 = {4,5,6}, vector2 = {1,2,3}
```

---

### .center[Vector - Funciones complementarias]

```c++
#include <vector>
#include <algorithm>
```

Imaginemos el vector definido como

```c++
vector<int> vector1 {3, 1, 2}; //Vector de tamaño 3
```


#### Función sort para ordenar de menor a mayor

```c++
sort(vector1.begin(), vector1.end()); //vector1 pasa a ser {1, 2, 3}
```

--

#### Función sort para ordenar de mayor a menor

```c++
sort(vector1.begin(), vector1.end(), greater<int>()); //vector1 pasa a ser {3, 2, 1}
```


---

### .center[Vector - Funciones complementarias]

#### Definir nosotros mismos como ordenar

Imaginemos que tenemos

```c++
struct quimico{
    int numero;
    int ganancia;
}

vector<quimico> quimicos {quimico1, quimico2, quimico3};
```

--

y queremos ordenarlos de menor a mayor con respecto a **numero Y ganancia**

```c++
sort(quimicos.begin(), quimicos.end(), miComparacion);

bool miComparacion(const quimico a, const quimico b) {
    if(a.numero!=b.numero) return a.numero<b.numero;
    else return a.ganancia<b.ganancia;
}
```

--

Este tipo de funciones "auxiliares" son muy útiles si tenemos arrays de structs y queremos usar sort. Usamos más de un return ya que, en estos casos, es más visible para la resolución del problema (similar a lo que nos pasaba en funciones recursivas).



???

Referencias:
https://aprende.olimpiada-informatica.org/cpp-sort

---

#### .center[Vector - Funciones complementarias]

##### Función push_back para insertar elementos

```c++
vector1.push_back(elemento); //Aumenta uno el tamaño de vector1, y agrega el elemento en la última posición.
```

--

##### Función pop_back para eliminar el último elemento

```c++
vector1.pop_back(); //Elimina el último elemento y reduce en uno el tamaño.
```

--

##### Función resize para modificar el tamaño del vector

```c++
vector1.resize(nuevoTamaño); //el vector pasa a tener como tamaño nuevoTamaño. Los elementos no definidos son automáticamente establecidos como 0.
```

--

##### Función insert

```c++
vector1.insert(vector1.begin()+indice, valor); //Inserta el valor en el índice definido.
```

--

##### Función clear

```c++
vector1.clear(); //elimina todos los elementos y establece el tamaño del vector como 0.
```

---

#### .center[Comparación y recorrido de vectores]

#### Para comparar, podemos usar la comparación elemento a elemento, o mirar el total del vector.

```c++
if (vector1[0] == vector2[5]) //Compara el valor que está en la posición 0 del vector1, con el valor que está en la posición 5 del vector2
if (vector1 == vector2) //Compara si vector 1 es igual a vector 2, verificando si todos los elementos de arreglo1 son iguales lexicográficamente a todos los elementos de vector2
```

--

#### Para recorrer un arreglo, en el taller usaremos dos formas

**Recorrido clásico**

```c++
for (int i = 0; i < vector1.size(); i++) 
    cout << vector1[i] << " ";
```

--

**Recorrido por elementos**

```c++
for (tipoDeDato elemento : vector1) 
    cout << elemento << " "; //Si el elemento es de una estructura, debemos hacer el acceso a sus atributos antes de imprimir.
```

--

**Encontrar máximo y mínimo elemento**

```c++
int maximo = *max_element(vector1.begin(), vector1.end());
int minimo = *min_element(vector1.begin(), vector1.end());
```

---

# Extra: matrices dinámicas

### Declaración

```c++
vector<vector<tipoDeDato>> nombreDeMatriz; //matriz de tamaño 0
```

--

### ¿Como podemos ingresar todos sus elementos?

```c++
nombreDeMatriz.resize(cantFilas);
int numeroIngreso;
for (int i = 0; i < cantFilas; i++) {
	for (int j = 0; j < cantColumnas; j++) {
		cin >> numeroIngreso;
		nombreDeMatriz[i].push_back(numeroIngreso);
	}
}
```

---


### Recorridos

**Recorrido clásico**

```c++
for (unsigned i = 0; i < nombreDeMatriz.size(); i++) {
	for (unsigned j = 0; j < nombreDeMatriz[i].size(); j++) 
		cout << nombreDeMatriz[i][j] << " ";
	cout << endl;
}
```

--

**Recorrido por elementos**

```c++
for (vector<int> fila : nombreDeMatriz) {
	for (int elemento : fila)
		cout << elemento << " ";
	cout << endl;
}
```

---

# Ejemplo de aplicación

**Problema**

"Definimos a la mediana como el valor en la posición central de un conjunto de datos **ordenados**.

Escribir un programa que reciba un numero N que representa una cantidad de mediciones,
luego, leer N mediciones e indicar cual es la mediana. Finalmente, imprimir los valores ordenados.

Aclaración: si N es par, la mediana es el promedio entre los dos valores centrales."

--

# Antes de resolver, simplificamos el problema

"Para un conjunto de números N, calcular su mediana y mostrarlos ordenados."

---

### Resolución

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	vector<int> mediciones;
	int n, medicion;
}
```

---

### Resolución

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	vector<int> mediciones;
	int n, medicion;
	
	cin >> n;
	
	for (int i = 0; i < n; i++) {
		cin >> medicion;
		mediciones.push_back(medicion);
	}
}
```

---

### Resolución

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	vector<int> mediciones;
	int n, medicion;
	
	cin >> n;
	
	for (int i = 0; i < n; i++) {
		cin >> medicion;
		mediciones.push_back(medicion);
	}
	
	sort(mediciones.begin(), mediciones.end());

	cout << "Mediana: ";
}
```

---

### Resolución

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	vector<int> mediciones;
	int n, medicion;
	
	cin >> n;
	
	for (int i = 0; i < n; i++) {
		cin >> medicion;
		mediciones.push_back(medicion);
	}
	
	sort(mediciones.begin(), mediciones.end());
	
	cout << "Mediana: ";
	int mitad = mediciones.size()/2; 
	if (n % 2 != 0) cout << mediciones[mitad] << endl;
	else cout << (mediciones[mitad - 1] + mediciones[mitad])/2.0 << endl;

	cout << "Arreglo: ";
}
```

---

### Resolución

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	vector<int> mediciones;
	int n, medicion;
	
	cin >> n;
	
	for (int i = 0; i < n; i++) {
		cin >> medicion;
		mediciones.push_back(medicion);
	}
	
	sort(mediciones.begin(), mediciones.end());
	
	cout << "Mediana: ";
	int mitad = mediciones.size()/2; 
	if (n % 2 != 0) cout << mediciones[mitad] << endl;
	else cout << (mediciones[mitad - 1] + mediciones[mitad])/2.0 << endl;
	
	cout << "Arreglo: ";
	for (int elemento : vector1) cout << elemento << " ";
	cout << endl;
}
```

---

class: inverse, center, middle

# Map

---

.left-column[
  ### Array
  ### Vector
  ### Map
]
.right-column[
Conceptos generales:
- El acceso sigue siendo mediante [] pero se cambia el concepto de índice por clave.
]

---

.left-column[
  ### Array
  ### Vector
  ### Map
]
.right-column[
Conceptos generales:
- El acceso sigue siendo mediante [] pero se cambia el concepto de índice por clave.
- A cada clave existente en un mapa se le corresponde un valor.
]

---

.left-column[
  ### Array
  ### Vector
  ### Map
]
.right-column[
Conceptos generales:
- El acceso sigue siendo mediante [] pero se cambia el concepto de índice por clave.
- A cada clave existente en un mapa se le corresponde un valor.
- Las claves **no necesariamente deben ser una secuencia ordenada de valores consecutivos**.
]

---

.left-column[
  ### Array
  ### Vector
  ### Map
]
.right-column[
Conceptos generales:
- El acceso sigue siendo mediante [] pero se cambia el concepto de índice por clave.
- A cada clave existente en un mapa se le corresponde un valor.
- Las claves **no necesariamente deben ser una secuencia ordenada de valores consecutivos**.
- Las claves pueden ser declaradas como de **cualquier tipo**.
]

---

.left-column[
  ### Array
  ### Vector
  ### Map
]
.right-column[
Conceptos generales:
- El acceso sigue siendo mediante [] pero se cambia el concepto de índice por clave.
- A cada clave existente en un mapa se le corresponde un valor.
- Las claves **no necesariamente deben ser una secuencia ordenada de valores consecutivos**.
- Las claves pueden ser declaradas como de **cualquier tipo**.
- El mapa **automáticamente** está ordenado por sus claves lexicográficamente.
]

---

# .center[Map]
```c++
#include <map>
```

### Declaración

```c++
map<tipoDeDatoClave, tipoDeDatoValor> nombreDelMapa; //Mapa con 0 elementos.
```

--

### Inicialización

```c++
map<tipoDeDatoClave, tipoDeDatoValor> nombreDelMapa { {clave1, dato1}, {clave2, dato2}, {clave3, dato3} }; //mapa con 3 pares clave-valor
```

--

### Acceso y modificación de elementos

```c++
nombreDelMapa[clave] = nuevoValor; //si la clave no tenía ningún valor, el mapa aumenta en uno su tamaño y el valor es asociado a la clave.
```
---

### .center[Map - Funciones integradas]

Imaginemos mapas definidos como

```c++
map<int, int> mapa1 { {1, 1}, {2, 2}, {3, 3} }; //Mapa de tamaño 3
map<int, int> mapa2 { {4, 4}, {5, 5}, {6, 6} }; //Mapa de tamaño 3
```

--

#### Funciones empty y size

```c++
cout << mapa1.empty() //Imprime 0 (devuelve false) ya que contiene elementos.
cout << mapa1.size() //Imprime 3 ya que el tamaño es 3.
```
--

#### Función swap

```c++
mapa1.swap(mapa2); //Intercambia el contenido de los mapas mapa1 = { {1, 1}, {2, 2}, {3, 3} }, vector2 = { {4, 4}, {5, 5}, {6, 6} } quedando vector1 = { {4, 4}, {5, 5}, {6, 6} }, vector2 = { {1, 1}, {2, 2}, {3, 3} }
```

--

#### Función count

```c++
mapa1.count(clave) //Devuelve 1 si la clave tiene algún valor asociado, y 0 en caso contrario.
```

---

## .center[Comparación y recorrido de mapas]

#### Para comparar, podemos usar la comparación elemento a elemento, o mirar el total del mapa.

```c++
if (mapa1["clave1"] == mapa2[5]) //Compara el valor que está en la clave "clave1" del mapa1, con el valor que está en la clave 5 del mapa22 
if (mapa1 == mapa2) //Compara si mapa1 es igual a mapa2, verificando si todos los elementos de mapa1 son iguales lexicográficamente a todos los elementos de mapa2
```
*Aclaración*: solo se comparan los valores, no las claves.

--

#### Para recorrer un mapa, en el taller usaremos un único tipo de recorrido.

--

**Recorrido por elementos**

```c++
for (pair<tipoDatoClave, tipoDatoValor> elemento : mapa1) {
    cout << "clave: " << elemento.first << " valor: " << elemento.second << " "; //Si el elemento es de una estructura, debemos hacer el acceso a sus atributos antes de imprimir.
}
```

---

# Ejemplo de aplicación

**Problema**

"Twitter es una red social que permite a los usuarios enviar mensajes públicos de hasta 240
caracteres. Generalmente dentro de la red se generan "tendencias" gracias a un análisis que hace
la plataforma sobre la cantidad de ocurrencias de una palabra durante un período determinado.

Como sos un ingeniero en sistemas de la UTN - FRSF (y, obviamente, un apasionado de los Algoritmos y 
Estructuras de Datos), decidiste trabajar para Twitter ya que la considerás una gran red social.
Para iniciar, te solicitaron que generes un sistema que reciba un número N de palabras (con
repetidas entre ellas), y un número M de consultas. Para cada consulta, deberás indicar cuantas 
apariciones tiene cada palabra."

--

# Antes de resolver, simplificamos el problema

"Para un conjunto de palabras N, contar la frecuencia de cada una. Luego, responder M consultas
con la frecuencia de la palabra correspondiente."

---

### Resolución

```c++
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main() {
	map<string, int> frecuencias; 
	int n, m;
	string palabra;
}
```

---

### Resolución

```c++
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main() {
	map<string, int> frecuencias; 
	int n, m;
	string palabra;
	
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin>>palabra;
		frecuencias[palabra]++;
	}
}
```

---

### Resolución

```c++
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main() {
	map<string, int> frecuencias; 
	int n, m;
	string palabra;
	
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin>>palabra;
		frecuencias[palabra]++;
	}
	
	cin >> m;
	for (int i = 0; i < m; i++) {
		cin>>palabra;
		cout << frecuencias[palabra] << endl;
	}
}
```

---

class: inverse, center, middle

# Set

---

.left-column[
  ### Array
  ### Vector
  ### Map
  ### Set
]
.right-column[
Conceptos generales:
- No podemos acceder de forma aleatoria (está prohibido el uso de []).
]

---

.left-column[
  ### Array
  ### Vector
  ### Map
  ### Set
]
.right-column[
Conceptos generales:
- No podemos acceder de forma aleatoria (está prohibido el uso de []).
- Conjunto ordenado (automáticamente) de elementos de un mismo tipo.
]

---

.left-column[
  ### Array
  ### Vector
  ### Map
  ### Set
]
.right-column[
Conceptos generales:
- No podemos acceder de forma aleatoria (está prohibido el uso de []).
- Conjunto ordenado (automáticamente) de elementos de un mismo tipo.
- Todos los elementos deben ser distintos.
]

---

.left-column[
  ### Array
  ### Vector
  ### Map
  ### Set
]
.right-column[
Conceptos generales:
- No podemos acceder de forma aleatoria (está prohibido el uso de []).
- Conjunto ordenado (automáticamente) de elementos de un mismo tipo.
- Todos los elementos deben ser distintos.
- Existe una variante llamada "unordered_set" que funciona igual, pero los elementos no están ordenados.
]

---

# .center[Set]
```c++
#include <set>
```

### Declaración

```c++
set<TipoDeDato> nombreDelSet; //set ordenado
unordered_set<TipoDeDato> nombreDelUnorderedSet; //set no ordenado
```

--

### Inicialización

```c++
set<TipoDeDato> nombreDelSet {dato1, dato2, dato3}; //los elementos se ordenan automáticamente y se eliminan los repetidos si existieran.
```

--

### Agregar un elemento

```c++
miSet.insert(elemento); //inserta elemento y re-ordena el set.
```

---

## .center[Comparación y recorrido de set]

#### Podemos comparar mirando el set completo.

```c++
if (set1 == set2) //Compara si set1 es igual a set2, verificando si todos los elementos de set1 son iguales lexicográficamente a todos los elementos de set2
```

--

#### Para recorrer un set, vamos a usar, al igual que en map, una única forma.

**Recorrido por elementos**

```c++
for (tipoDeDato elemento : set) 
    cout << elemento << " "; //Si el elemento es de una estructura, debemos hacer el acceso a sus atributos antes de imprimir.
```

---

### Ejemplo de aplicación

**Problema**

Valentina es una mujer muy dedicada que trabaja hasta tarde todos los días. Para ahorrar tiempo,
ella escribe todos los ítems al mismo tiempo que los recuerda. Ella usa una aplicación móvil para
esta tarea.

El problema es que esta aplicación no elimina los ítems duplicados y, como Valentina es distraída,
ella frecuentemente anota el mismo ítem más de una vez y la lista se hace demasiado larga.
Tu trabajo consta en mejorar esa aplicación, por lo que tendrás que escribir un programa que
excluya ítems duplicados de la lista de compras y los ordene en orden alfabético.

La entrada consta de un número N (cantidad de ítems), seguida de N ítems separados por un espacio.

**Versión simplificada del problema**
https://www.beecrowd.com.br/judge/es/problems/view/2729

### Antes de resolver, simplificamos el problema

Leer un número N de palabras y mostrarlos en pantalla sin repetidos y en órden alfabético.

---

### Resolución

```c++
#include <iostream>
#include <set>

using namespace std;

int main() {
	set<string> items;
	int n;
	string palabra;
}
```

---

### Resolución

```c++
#include <iostream>
#include <set>

using namespace std;

int main() {
	set<string> items;
	int n;
	string palabra;
	
	cin >> n;
	
	for (int i = 0; i < n; i++) {
		cin >> palabra;
		items.insert(palabra);
	}
}
```

---

### Resolución

```c++
#include <iostream>
#include <set>

using namespace std;

int main() {
	set<string> items;
	int n;
	string palabra;
	
	cin >> n;
	
	for (int i = 0; i < n; i++) {
		cin >> palabra;
		items.insert(palabra);
	}
	
	for (string elemento : items) cout << elemento << " ";
	cout << endl;
}
```

---

# Aclaración general

* En todas las estructuras vistas, el elemento por default si no hay una asignación es **0**. Los elementos no contienen basura por defecto.

---

# Algunos temas útiles que no se dictan en el taller

--

* Iteradores

--

* Deque, queue, priority queue, stack

--

* Macros


Todos estos temas están contenidos dentro del libro "Competitive Programmer's Handbook"

https://cses.fi/book/book.pdf

---

# Formas de seguir aprendiendo

* Resolviendo problemas de jueces en línea (codeforces, leetcode, uri, etc.)

--

* Participando de competencias de programación.

--

* Leyendo bibliografía.

--

* Participando de la comunidad de programación competitiva de la UTN - FRSF.
https://discord.gg/VEsMc9qU

---

class: inverse, center, middle

# Fin de la parte teórica

### Contacto: tassenza@frsf.utn.edu.ar (o, por mensaje privado de Teams).

### ¡Gracias por participar de parte del Equipo de Algoritmos y Estructuras de Datos!
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create({ slideNumberFormat: ""});
    </script>
  </body>
</html>

